.path = pyimport "path"
# .PathLike: ClassType

.OSError = OSError
.PathLike = PathLike

.DirEntry: ClassType
.DirEntry.
    name: Str
    path: Str
    inode: (self: .DirEntry) -> Nat
    is_dir: (self: .DirEntry, follow_symlinks := Bool) -> Bool
    is_file: (self: .DirEntry, follow_symlinks := Bool) -> Bool
    is_symlink: (self: .DirEntry) -> Bool
    is_junction: (self: .DirEntry) -> Bool
    stat: (self: .DirEntry, follow_symlinks := Bool) -> .StatResult

.StatResult = 'stat_result': ClassType
.StatResult.
    st_mode: Nat
    st_ino: Nat
    st_dev: Nat
    st_nlink: Nat
    st_uid: Nat
    st_gid: Nat
    st_size: Nat
    st_atime: Float
    st_mtime: Float
    st_ctime: Float
    st_atime_ns: Nat
    st_mtime_ns: Nat
    st_ctime_ns: Nat
    st_birthtime: Float
    st_birthtime_ns: Nat
    st_blocks: Nat
    st_blksize: Nat
    st_rdev: Nat
    st_flags: Nat
    st_gen: Nat
    st_fstype: Nat
    st_rsize: Nat
    st_creator: Nat
    st_type: Nat
    st_file_attributes: Nat
    st_reparse_tag: Nat

# TODO: _Environ
.environ: {Str: Str}
.environb: {Bytes: Bytes}
'''
The name of the operating system dependent module imported. The following names have currently been registered:
    'posix', 'nt', 'java'.
'''
.name: Str
.supports_bytes_environ: Bool
.supports_dir_fd: Set Subroutine, _
.supports_effective_ids: Set Subroutine, _
.supports_fd: Set Subroutine, _
.supports_follow_symlinks: Set Subroutine, _

.F_LOCK: Nat
.F_TLOCK: Nat
.F_ULOCK: Nat
.F_TEST: Nat

.O_RDONLY: Nat
.O_WRONLY: Nat
.O_RDWR: Nat
.O_APPEND: Nat
.O_CREAT: Nat
.O_EXCL: Nat
.O_TRUNC: Nat
.O_DSYNC: Nat
.O_RSYNC: Nat
.O_SYNC: Nat
.O_NDELAY: Nat
.O_NONBLOCK: Nat
.O_NOCTTY: Nat
.O_CLOEXEC: Nat
.O_BINARY: Nat
.O_NOINHERIT: Nat
.O_SHORT_LIVED: Nat
.O_TEMPORARY: Nat
.O_RANDOM: Nat
.O_SEQUENTIAL: Nat
.O_TEXT: Nat
.O_EVTONLY: Nat
.O_FSYNC: Nat
.O_SYMLINK: Nat
.O_NOFOLLOW_ANY: Nat
.O_ASYNC: Nat
.O_DIRECT: Nat
.O_DIRECTORY: Nat
.O_NOFOLLOW: Nat
.O_NOATIME: Nat
.O_PATH: Nat
.O_TMPFILE: Nat
.O_SHLOCK: Nat
.O_EXLOCK: Nat

.POSIX_FADV_NORMAL: Nat
.POSIX_FADV_SEQUENTIAL: Nat
.POSIX_FADV_RANDOM: Nat
.POSIX_FADV_NOREUSE: Nat
.POSIX_FADV_WILLNEED: Nat
.POSIX_FADV_DONTNEED: Nat

.PRIO_PGRP: Nat
.PRIO_PROCESS: Nat
.PRIO_USER: Nat
.PRIO_DARWIN_THREAD: Nat
.PRIO_DARWIN_PROCESS: Nat
.PRIO_DARWIN_BG: Nat
.PRIO_DARWIN_NONUI: Nat

.RWF_APPEND: Nat
.RWF_DSYNC: Nat
.RWF_HIPRI: Nat
.RWF_NOWAIT: Nat
.RWF_SYNC: Nat

.SEEK_SET: Nat
.SEEK_CUR: Nat
.SEEK_END: Nat
.SEEK_HOLE: Nat
.SEEK_DATA: Nat

.SF_MNOWAIT: Nat
.SF_NOCACHE: Nat
.SF_NODISKIO: Nat
.SF_SYNC: Nat

.close!: (fd: Nat or FileDescriptor) => NoneType
.closerange!: (fd_low: Nat, fd_high: Nat) => NoneType
.ctermid!: () => Str
.chdir!: (path: PathLike, ) => NoneType
.chmod!: (path: PathLike, mode: Nat) => NoneType
.copy_file_range!: (src: Nat or FileDescriptor, dst: Nat or FileDescriptor, count: Nat, offset_src := Nat, offset_dst := Nat) => Nat
.device_encoding: (fd: Nat or FileDescriptor) -> Str or NoneType
.dup!: (fd: Nat or FileDescriptor) => Nat
.dup2!: (fd: Nat or FileDescriptor, fd2: Nat, inheritable := Bool) => Nat
.fchdir!: (fd: Nat or FileDescriptor) => NoneType
.fchmod!: (fd: Nat or FileDescriptor, mode: Nat) => NoneType
.fchown!: (fd: Nat or FileDescriptor, uid: Nat, gid: Nat) => NoneType
.fdatasync!: (fd: Nat or FileDescriptor) => NoneType
.fdopen!: (fd: Nat or FileDescriptor, *args: Obj, **kwargs: Obj) => File!
.fpathconf!: (fd: Nat or FileDescriptor, name: Nat) => Nat
.fsdecode: (filename: Bytes) -> Str
.fsencode: (filename: Str) -> Bytes
.fspath: (path: PathLike) -> Str
.fstat!: (fd: Nat or FileDescriptor) => .StatResult
.fstatvfs!: (fd: Nat or FileDescriptor) => .StatResult
.fsync!: (fd: Nat or FileDescriptor) => NoneType
.ftruncate!: (fd: Nat or FileDescriptor, length: Nat) => NoneType
.fwalk!: (
    top := PathLike,
    topdown := Bool,
    onerror := Subroutine,
    follow_symlinks := Bool,
    dir_fd := Nat or FileDescriptor,
) => Iterator [Str, [Str; _], [Str; _], Nat]
.get_blocking!: (fd: Nat or FileDescriptor) => Bool
.get_exec_path!: (env := {Str: Str}) => [Str; _]
.getcwd!: () => Str
.getcwdb!: () => Bytes
.getegid!: () => Nat
.getenv!: |D <: Str or NoneType|(key: Str, default: D := NoneType) => Str or D
.getenvb!: |D <: Bytes or NoneType|(key: Bytes, default: D := NoneType) => Bytes or D
.geteuid!: () => Nat
.getgid!: () => Nat
.getgrouplist!: (user: Str, group: Nat) => [Nat; _]
.getgroups!: () => [Nat; _]
.getlogin!: () => Str
.getpgid!: (pid: Nat) => Nat
.getpgrp!: () => Nat
.getpid!: () => Nat
.getppid!: () => Nat
.getpriority!: (which: Nat, who: Nat) => Nat
.getrandom!: (size: Nat) => Bytes
.getresgid!: () => (Nat, Nat, Nat)
.getresuid!: () => (Nat, Nat, Nat)
.getsid!: (pid: Nat) => Nat
.getuid!: () => Nat
.initgroups!: (username: Str, gid: Nat) => NoneType
.isatty!: (fd: Nat or FileDescriptor) => Bool
.listdir!: (path := PathLike,) => [Str; _]
.lockf!: (fd: Nat or FileDescriptor, cmd: Nat, len := Nat) => NoneType
.login_tty!: (fd: Nat or FileDescriptor) => NoneType
.lseek!: (fd: Nat or FileDescriptor, pos: Nat, whence: Nat) => Nat
.mkdir!: (path: PathLike, mode := Nat) => NoneType
.makedirs!: (path: PathLike, mode := Nat, exist_ok := Bool) => NoneType
.open!: (path: PathLike, flags: Nat, mode := Nat, dir_fd := Nat or FileDescriptor) => Nat
.openpty!: () => (Nat, Nat)
.pipe!: () => (Nat, Nat)
.pipe2!: (flags: Nat) => (Nat, Nat)
# TODO: only on linux
.posix_fallocate!: (fd: Nat or FileDescriptor, offset: Nat, len: Nat) => NoneType
.posix_fadvise!: (fd: Nat or FileDescriptor, offset: Nat, len: Nat, advice: Nat) => NoneType
.pread!: (fd: Nat or FileDescriptor, n: Nat, offset: Nat) => Bytes
.preadv!: (fd: Nat or FileDescriptor, buffers: RefMut(ByteArray!), offset: Nat, flags := Nat) => Nat
.putenv!: (key: Str, value: Str) => NoneType
.pwrite!: (fd: Nat or FileDescriptor, str: Bytes, offset: Nat) => Nat
.pwritev!: (fd: Nat or FileDescriptor, buffers: Ref(ByteArray!), offset: Nat, flags := Nat) => Nat
.read!: (fd: Nat or FileDescriptor, n: Nat) => Bytes
.readlink!: (path: PathLike, dir_fd := Nat or FileDescriptor) => Str
.remove!: (path: PathLike,) => NoneType
.removedirs!: (path: PathLike,) => NoneType
.rename!: (src: PathLike, dst: PathLike) => NoneType
.renames!: (old: PathLike, new: PathLike) => NoneType
.replace!: (src: PathLike, dst: PathLike) => NoneType
.rmdir!: (path: PathLike,) => NoneType
.scandir!: (path := PathLike,) => Iterator DirEntry
.sendfile!: (out_fd: Nat or FileDescriptor, in_fd: Nat or FileDescriptor, offset := Nat, count := Nat) => Nat
.set_blocking!: (fd: Nat or FileDescriptor, blocking: Bool) => NoneType
.setegid!: (egid: Nat) => NoneType
.seteuid!: (euid: Nat) => NoneType
.setgid!: (gid: Nat) => NoneType
.setgroups!: (groups: Sequence(Nat)) => NoneType
.setns!: (fd: Nat or FileDescriptor, nstype := Nat) => NoneType
.setpgrp!: () => NoneType
.setpgid!: (pid: Nat, pgid: Nat) => NoneType
.setpriority!: (which: Nat, who: Nat, priority: Nat) => NoneType
.setregid!: (rgid: Nat, egid: Nat) => NoneType
.setresgid!: (rgid: Nat, egid: Nat, sgid: Nat) => NoneType
.setresuid!: (ruid: Nat, euid: Nat, suid: Nat) => NoneType
.setreuid!: (ruid: Nat, euid: Nat) => NoneType
.setsid!: () => Nat
.setuid!: (uid: Nat) => NoneType
.statvfs!: (path: PathLike) => NamedTuple {
    .f_bsize = Nat;
    .f_frsize = Nat;
    .f_blocks = Nat;
    .f_bfree = Nat;
    .f_bavail = Nat;
    .f_files = Nat;
    .f_ffree = Nat;
    .f_favail = Nat;
    .f_flag = Nat;
    .f_namemax = Nat;
    .f_fsid = Nat;
}
.strerror: (code: Nat) -> Str
.symlink!: (src: PathLike, dst: PathLike, target_is_directory := Bool, dir_fd := Nat or FileDescriptor) => NoneType
.sync!: () => NoneType

.umask!: (mask: Nat) => Nat
# posix = pyimport "posix"
# .uname!: () => posix.UnameResult
.uname!: () => NamedTuple {
    sysname = Str;
    nodename = Str;
    release = Str;
    version = Str;
    machine = Str;
}
.unlink!: (path: PathLike, dir_fd := Nat or FileDescriptor) => NoneType
.unsetenv!: (key: Str) => NoneType
.unshare!: (flags: Nat) => NoneType
.urandom!: (size: Nat) => Bytes
.utime!: (path: PathLike, times := (Float, Float)) => NoneType

.walk!: (
    top: PathLike,
    topdown := Bool,
    onerror := Subroutine,
    followlinks := Bool
) => Iterator [Str, [Str; _], [Str; _]]
