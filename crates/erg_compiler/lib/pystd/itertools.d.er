.Count: ClassType
.Count <: Iterable Int
.Count.
    __call__: (start: Int, step: Int) -> .Count
.count: (start: Int, step: Int) -> .Count

.Cycle: ClassType
.Cycle.
    __call__: |T|(iterable: Iterable T) -> Iterable T
.cycle: |T|(iterable: Iterable T) -> Iterable T

.Repeat: ClassType
.Repeat.
    __call__: |T|(value: T, times := Nat) -> Iterable T
.repeat: |T|(value: T, times := Nat) -> Iterable T

.Accumulate: ClassType
.Accumulate.
    __call__: |T|(iterable: Iterable(T), func := (T, T) -> T) -> Iterable T
.accumulate: |T|(iterable: Iterable(T), func := (T, T) -> T) -> Iterable T

.Chain: ClassType
.Chain.
    __call__: |T|(*iterables: Iterable T) -> Iterable T
.chain: |T|(*iterables: Iterable T) -> Iterable T

.Compress: ClassType
.Compress.
    __call__: |T|(data: Iterable(T), selectors: Iterable Bool) -> Iterable T
.compress: |T|(data: Iterable(T), selectors: Iterable Bool) -> Iterable T

.DropWhile: ClassType
.DropWhile.
    __call__: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T
.dropwhile: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T

.FilterFalse: ClassType
.FilterFalse.
    __call__: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T
.filterfalse: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T

.GroupBy: ClassType
.GroupBy.
    __call__: |T, K|(iterable: Iterable(T), key := (T) -> K) -> Iterable((K, Iterable(T)))
.groupby: |T, K|(iterable: Iterable(T), key := (T) -> K) -> Iterable((K, Iterable(T)))

.Islice: ClassType
.Islice.
    __call__: |T|(iterable: Iterable(T), start := Int, stop := Int, step := Int) -> Iterable T
.islice: |T|(iterable: Iterable(T), start := Int, stop := Int, step := Int) -> Iterable T

.Pairwise: ClassType
.Pairwise.
    __call__: |T|(iterable: Iterable(T)) -> Iterable((T, T))
.pairwise: |T|(iterable: Iterable(T)) -> Iterable((T, T))

# .Startmap = 'startmap': ClassType
# .Startmap.
#     __call__: |T|(function: (T) -> T, iterable: Iterable T) -> Iterable T

.Takewhile: ClassType
.Takewhile.
    __call__: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T
.takewhile: |T|(predicate: (T) -> Bool, iterable: Iterable T) -> Iterable T

.Tee: ClassType
.Tee.
    __call__: |T|(iterable: Iterable(T), n := Nat) -> [Iterable(T); _]
.tee: |T|(iterable: Iterable(T), n := Nat) -> [Iterable(T); _]

.ZipLongest: ClassType
.ZipLongest.
    __call__: |T|(*iterables: Iterable(T), fillvalue := T) -> Iterable [T; _]
.zip_longest: |T|(*iterables: Iterable(T), fillvalue := T) -> Iterable [T; _]

.Product: ClassType
.Product.
    __call__: |T|(*iterables: Iterable(T), repeat := Nat) -> Iterable [T; _]
.product: |T|(*iterables: Iterable(T), repeat := Nat) -> Iterable [T; _]

.Permutations: ClassType
.Permutations.
    __call__: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]
.permutations: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]

.Combinations: ClassType
.Combinations.
    __call__: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]
.combinations: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]

.CombinationsWithReplacement: ClassType
.CombinationsWithReplacement.
    __call__: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]
.combinations_with_replacement: |T|(iterable: Iterable(T), r := Nat) -> Iterable [T; _]
